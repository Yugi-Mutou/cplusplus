# 静态链接库

.lib文件是静态链接库，它包含了一组已编译好的函数和数据，可以被链接到一个可执行文件中。当程序运行时，链接器会将这些函数和数据复制到可执行文件中，使得程序在运行时可以直接调用这些函数和数据。

## 优缺点

因为静态链接库被完全包含在可执行文件中，所以它们不需要在运行时加载，因此速度较快，但会增加可执行文件的大小。



静态链接库是在链接的时候被包含进来了，也就是说，是生成的.o文件和链接库连接么？

- 是的，你说的很对。静态链接库在链接时被包含进可执行文件中，也就是在生成可执行文件的过程中将.o文件和静态链接库连接起来。

- 具体来说，当你编译一个程序时，编译器会将你的源代码（.cpp文件）编译成目标文件（.o或.obj文件），然后将这些目标文件链接为可执行文件。在链接的过程中，如果你使用了静态链接库，那么编译器会将**静态链接库中的目标文件也链接进可执行文件中，使得你的程序可以调用静态链接库中的函数和数据**。

- 因此，静态链接库实际上就是一组目标文件的打包，当你使用静态链接库时，它会被链接进可执行文件中，成为可执行文件的一部分。这样做的好处是，可以将常用的代码打包成静态链接库，方便在多个程序中共享使用，同时也可以减小可执行文件的大小。



# 动态链接库

.dll文件是动态链接库，它包含了一组已编译好的函数和数据，**可以在运行时被加载到内存中并被程序调用**。由于.dll文件并不在可执行文件中，所以多个程序可以共享同一个.dll文件

## 优缺点

可以减小程序的内存占用，但由于需要在运行时进行加载，所以速度相对较慢。

- 动态链接库（.dll文件）与静态链接库不同，它并不在编译时被链接到可执行文件中，而是在运行时被加载到内存中并被程序调用。

- 具体来说，当你编译一个程序时，编译器并不会将动态链接库中的函数和数据链接到可执行文件中。相反，当你运行程序时，操作系统会动态地加载动态链接库到内存中，并将程序中调用动态链接库中函数的地址指向动态链接库中相应的函数。这样，程序就可以在运行时调用动态链接库中的函数和数据了。

- 因此，动态链接库并不是被链接进可执行文件中，而是在运行时被加载到内存中。这样做的好处是，多个程序可以共享同一个动态链接库，从而减小程序的内存占用，同时也方便对动态链接库进行更新和维护。



# 区别

静态库被链接到可执行文件，动态库并不在可执行文件，只是加载到内存，等程序需要的时候再链接。



# DLLEXPORT和DLLIMPORT

## DLLEXPORT

DLLEXPORT是一个标识符，通常用于指定在编译动态链接库(DLL)时应该导出符号。在Windows平台上，如果您编译一个DLL，您**需要明确指定哪些函数和数据应该导出到DLL的符号表中**，以便其他程序可以使用它们。使用DLLEXPORT宏定义可以在编译时将函数和数据导出到符号表中。

在UE引擎中，ENGINE_API是一个用于标识引擎核心模块的宏定义。在编写UE引擎的内部代码时，使用ENGINE_API宏定义可以将函数和数据导出到引擎的符号表中，以便其他模块和插件可以使用它们。



## DLLIMPORT

DLLIMPORT是一个宏定义，通常用于指定在编译动态链接库(DLL)时应该导入符号。在Windows平台上，如果您编译一个DLL，您需要明确指定哪些函数和数据应该导入到DLL的符号表中，以便在DLL中使用它们。使用DLLIMPORT宏定义可以在编译时将函数和数据标记为需要导入的符号。

在UE中，DLLIMPORT通常用于将DLL中的函数和数据导入到引擎或插件的代码中。例如，当您编写一个UE插件时，您可能需要使用UE引擎或其他插件中的函数和数据。在这种情况下，您可以使用DLLIMPORT宏定义将这些函数和数据标记为需要导入的符号，以便在编译时将它们导入到您的插件中。

```c++
// 举例说明
#define CORE_API DLLIMPORT
// 此时我如果想用动态链接库里的函数或者类
class CORE_API FString;
class CORE_API FName;
```





# UE中的动态链接

UE引擎中使用了动态链接库（Dynamic Link Library，DLL）来实现动态链接。UE引擎中的DLL包含了许多可重用的代码和资源，例如渲染器、网络通信、音频系统等等。这些**DLL可以在运行时动态加载到内存中，并且只有在需要时才会被链接到可执行文件中**。

UE引擎中的动态链接的操作过程可以简单概括为以下几个步骤：

1. 编写代码并生成动态链接库。
2. 在UE引擎项目中添加动态链接库的路径和名称。
3. 在代码中动态加载和链接需要使用的DLL。
4. 在需要使用DLL的地方调用相关的函数。

具体来说，根据UE引擎的工作原理，UE引擎会在程序启动时加载所需的DLL，并且只有**在需要时才会将DLL中的函数链接到可执行文件中**。在代码中，可以使用动态链接库的函数和资源，例如使用UE提供的渲染器API来渲染场景，使用网络通信API来实现游戏联机功能等等。为了使用DLL，可以使用UE提供的一些函数来加载和链接DLL中的函数，例如LoadLibrary和GetProcAddress函数。

需要注意的是，动态链接库在使用过程中需要遵循一些规则，例如需要保证DLL的版本和平台与应用程序一致，需要正确处理DLL中的内存和资源等等。因此，在使用动态链接库时需要注意一些细节和技巧。

## DLL文件

直接生成好的DLL本质上就是一堆二进制代码和数据的集合，它包含了功能代码、数据、资源和元数据等信息。这些二进制数据可以在程序运行时动态加载到内存中，并且可以通过动态链接的方式在可执行文件中使用，从而实现代码的重用和共享。

在生成DLL时，编译器会将源代码编译成目标文件（Object File），然后将目标文件链接成DLL。链接的过程包括了符号解析、地址重定向、代码合并等操作，最终生成可供使用的DLL文件。**DLL文件通常包含了导出表（Export Table），其中记录了DLL中导出函数的名称、地址和参数信息等。当程序需要使用DLL中的函数时，通过导出表可以定位到相应的函数入口地址，然后执行相应的功能**。



## 为什么UE每次都要编译生成动态链接库

UE引擎之所以在编译时生成动态链接库（DLL），而不是直接提供给用户生成好的DLL文件，是因为UE引擎是一个庞大而复杂的系统，其中包含了许多不同的模块和功能。为了提高可维护性和灵活性，UE引擎将这些模块和功能分成了许多独立的DLL，这些DLL可以单独编译、测试和部署。这样，当某个模块需要更新或修复时，只需要重新编译对应的DLL，而不需要重新编译整个引擎。

另外，UE引擎也支持**用户自定义DLL**，以便用户可以将自己的代码和资源打包成DLL，供其他用户或引擎项目使用。如果UE引擎直接提供给用户生成好的DLL文件，这将会限制用户的自定义和扩展能力。**其实自己创建的c++类就是自定义的DLL**

因此，UE引擎在编译时生成动态链接库，可以提高引擎的可维护性和灵活性，同时也支持用户自定义DLL，以满足不同用户的需求。虽然在使用过程中需要一些额外的操作，但这也为用户提供了更多的自由和选择。
