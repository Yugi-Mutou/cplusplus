# 内存对齐

```c++
struct{
    int x;
    char y;
}Test;
// 理论上是5B，因为内存对齐结果是8B
```



## 为什么要内存对齐

1. 平台原因(移植原因):不是所有的硬件平台都能访问任意地址上的任意数据的.
2. 性能原因:数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。



## 内存对齐规则

1. **基本类型**的对齐值就是其sizeof值;
2. **数据成员对齐规则**：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，**以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行**;
3. **结构(或联合)的整体对齐规则**：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对**齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行**;

![image-20230915171746725](C:\Users\17862\Desktop\MyGitHub\cplusplus\assets\image-20230915171746725.png)

```c++
#include<iostream>
using namespace std;

class MyClass2 {
	char a;
	double b;
	char c;
};

class MyClass {
	char a;
	MyClass2 b;
	char c;
};

class My:public MyClass {
	char c;
};

int main() {
	MyClass a;
	cout << sizeof(MyClass2) << endl; // 24
	cout << sizeof(a) << endl;        // 40 = 8 + 24 + 8
	cout << sizeof(My) << endl;       // 48
	return 0;
}

// 如果把double改成char，则输出为 3 5 6
// 所以在64位机器上应该慎用比较大的结构体，它会导致偏移变大(最大为8)，可能造成很多空隙
```





## 位域

所谓“位域”，就是把一个字节中的“位”按照实际的需求分成不同的区域，表明每个区域位数、区域的域名，并允许程序按照域名进行操作。**如此就可以把不同的对象用一个字节来表示**。

位域：【类型说明符】 【位域名】：【位域的长度】

1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。
2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是不能超过8位二进位。
3. 位域可以无位域名，这时它只用来填充或调整位置。无名的位域是不能使用的。

```c++
struct S1
{
    int i : 8;
    char j : 4;
    int a : 4;
};
sizeof(S1)=12 // 4+4+4
    
    
struct S2
{
    int i : 8;
    char j : 4;
    int a : 4;
    double b;
};
sizeof(S2)=24   // (4+4+4)=12 double只能以8的整数开存,所以从16开始
```







































