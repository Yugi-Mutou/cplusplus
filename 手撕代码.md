# string

```c++
#include<cstring>
using namespace std;

class MyString {
private:
	int length;
	char* data;
public:
	// 构造函数
	MyString() : length(0), data(nullptr) {}
	MyString(int n, char d) {
		length = n;
		data = new char[length + 1];
		memset(data, d, n);
		data[n] = '\0';
	}
	MyString(const char* d) {
		length = strlen(d);
		data = new char[length + 1];
		strcpy(data, d);
	}
    
    // 移动构造函数
    String(String&& other) noexcept : data(nullptr), length(0) {
        data = other.size();
        length = other.get_data_pointer();
        // 进入可析构状态
        other.data = nullptr;
        other.length = 0;
    }

    // 移动赋值函数
    String& operator=(String&& other) noexcept {
        // 进行判断，很重要
        if (this != &other) {
            delete[] data;
            data = other.get_data_pointer();
            length = other.size();
            // 进入可析构状态
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }
    
    // 拷贝赋值函数
    String& operator=(const String& other) {
        // 进行判断，很重要
        if (this != &other) {
            delete[] data;
            if (other..get_data_pointer()) {
                length = other.size();
                data = new char[length + 1];
                std::strcpy(data, other.data);
            } else {
                data = nullptr;
                length = 0;
            }
        }
        return *this;
    }

	// 析构函数
	~MyString()
	{
		delete[] data;
	}

	// 常用成员函数
	int size() const {
		return length;
	}
    
    char* get_data_pointer() const{
        return data;
    }

	char& operator[](int n){
		return *(data + n);
	}
};
```

# memset

```c++
void* memset(void* ptr, int value, size_t num) {
	unsigned char* p = static_cast<unsigned char*>(ptr);
	unsigned char v = static_cast<unsigned char>(value);
	for (size_t i = 0; i < num; i++) {
		*(p + i) = v;
	}
	return p;
}
```



# memcpy

```c++
void* memcpy(void* dest,const void* src,size_t n){
    char* t=dest;
    const char* s=src;
    while(n--){
        *t=*s;
        t++;
        s++;
    }
    return dest;
}
```

# memmove

```c++
void* memmove(void* dest,const void* src,size_t n){
    char* t;
    const char* s;
    if(dest<=src){
        t=dest;
        s=src;
        while(n--){
            *t=*s;
            t++;
            s++;
        }
    }else{
        t=dest+n;
        s=src+n;
        while(n--){
            --t;
            --s;
            *t=*s;
        }
    }
    return dest;
}
```



# 插入排序

```c++
void insert_sor(vector<int>& arr){
    int n=arr.size();
    if(n==1) return;
    for(int i=1;i<n;i++){
        int key=arr[i];
        int j=i-1;
        while(j>=0 && key<arr[j]){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}
```

# 快排

```c++
void MySort(vector<int>& nums,int begin,int end){
    if(begin>end) return ;
    int left=begin,right=end;
    int base=nums[begin];
    while(left<right){
        while(left<right && nums[left]<=base) left++;
        while(left<right && nums[right]>=base) right--;
        if(left<right){
            swap(nums[left],nums[right]);
        }
    }
    nums[begin]=nums[left];
    nums[left]=base;
    
    MySort(nums,begin,left-1);
    MySort(nums,left+1,end);
    
}
```

# 中序遍历

```c++
vector<int> inorder(TreeNode* root){
    stack<TreeNode*> st;
    vector<int> ans;
    while(root || !st.empty()){
        while(root){
            st.push(root);
            root=root->left;
        }
        TreeNode* temp=st.top();
        st.pop();
        ans.push_back(temp->val);
        root=temp->right;
    }
    return ans;
}
```

# 二分+并查集

n个人，差别值为能力值和性格值之差的和，差别值不超过L的两个人必然在一个组里，所有人至少能分成k个非空小组，规定的差别值上限是多少。

```c++

#include<vector>
#include<iostream>
#define ll long long
using namespace std;
int n, k;
vector<ll> a;
vector<ll> b;
ll g[501][501];
int father[501];
ll dis(int i, int j) { return abs(a[i] - a[j]) + abs(b[i] - b[j]); }
void init() {
	for (int i = 0; i <= n; i++) {
		father[i] = i;
	}
}
int find(int x) {
	if (x != father[x]) {
		father[x] = find(father[x]);
	}
	return father[x];
}
void merge(int x, int y) {
	int fx = find(x);
	int fy = find(y);
	if (fx != fy) {
		father[fx] = fy;
	}
}
bool check(ll x) {
	init();
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			if (g[i][j] <= x) {
				merge(i, j);
			}
		}
	}
	vector<bool> vis(n, false);
	for (int i = 0; i < n; i++) {
		vis[find(i)] = true;
	}
	int cur = 0;
	for (int i = 0; i < n; i++) {
		if (vis[i]) {
			cur++;
		}
	}

	return cur >= k;
}
int main() {
	cin >> n >> k;
	a.resize(n, 0);
	b.resize(n, 0);
	ll MIN = 1000000000;
	ll MAX = 0;
	for (int i = 0; i < n; i++) cin >> a[i];
	for (int i = 0; i < n; i++) cin >> b[i];
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			ll d = dis(i, j);
			g[i][j] = d;
			g[j][i] = d;
			MIN = min(MIN, d);
			MAX = max(MAX, d);
		}
	}
    // 差别值越大，分的小组越少
    // 差别值越小，分的小组越多
	ll l = MIN, r = MAX + 1;
	while (l < r) {
		int mid = (l + r) / 2;
		if (check(mid)) {
			l = mid + 1;
		}
		else {
			r = mid;
		}
	}
	cout << l - 1;
	return 0;
}
/*
3 2
1 9 3
2 7 8
*/
```

