# string

```c++
#include<cstring>
using namespace std;

class MyString {
private:
	int length;
	char* data;
public:
	// 构造函数
	MyString() : length(0), data(nullptr) {}
	MyString(int n, char d) {
		length = n;
		data = new char[length + 1];
		memset(data, d, n);
		data[n] = '\0';
	}
	MyString(const char* d) {
		length = strlen(d);
		data = new char[length + 1];
		strcpy(data, d);
	}
    
    // 移动构造函数
    String(String&& other) noexcept : data(nullptr), length(0) {
        data = other.get_data_pointer();
        length = other.size();
        // 进入可析构状态
        other.data = nullptr;
        other.length = 0;
    }

    // 移动赋值函数
    String& operator=(String&& other) noexcept {
        // 进行判断，很重要
        if (this != &other) {
            delete[] data;
            data = other.get_data_pointer();
            length = other.size();
            // 进入可析构状态
            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }
    
    // 拷贝赋值函数
    MyString& operator=(const MyString& other);

	// 析构函数
	~MyString()
	{
		delete[] data;
	}

	// 常用成员函数
	int size() const {
		return length;
	}
    
    char* get_data_pointer() const{
        return data;
    }

	char& operator[](int n){
		return *(data + n);
	}
};
```

```c++
// 拷贝赋值函数
MyString& MyString::operator=(const MyString& rhs){
    if(this==&rhs){
        return *this
    }
    delete [] data;
    length=strlen(rhs.data);
    data=new char[length+1];
    strcpy(data, rhs.data);
    return *this;
}
```



# memset

```c++
void* memset(void* ptr, int value, size_t num) {
	unsigned char* p = static_cast<unsigned char*>(ptr);
	unsigned char v = static_cast<unsigned char>(value);
	for (size_t i = 0; i < num; i++) {
		*(p + i) = v;
	}
	return p;
}
```



# memcpy

```c++
void* memcpy(void* dest,const void* src,size_t n){
    char* t=dest;
    const char* s=src;
    while(n--){
        *t=*s;
        t++;
        s++;
    }
    return dest;
}
```

# memmove

```c++
void* memmove(void* dest,const void* src,size_t n){
    char* t;
    const char* s;
    if(dest<=src){
        t=dest;
        s=src;
        while(n--){
            *t=*s;
            t++;
            s++;
        }
    }else{
        t=dest+n;
        s=src+n;
        while(n--){
            --t;
            --s;
            *t=*s;
        }
    }
    return dest;
}
```



# 插入排序

```c++
void insert_sor(vector<int>& arr){
    int n=arr.size();
    if(n==1) return;
    for(int i=1;i<n;i++){
        int key=arr[i];
        int j=i-1;
        while(j>=0 && key<arr[j]){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=key;
    }
}
```

# 快排

```c++
void MySort(vector<int>& nums,int begin,int end){
    if(begin>end) return ;
    int left=begin,right=end;
    int base=nums[begin];
    while(left<right){
        while(left<right && nums[left]<=base) left++;
        while(left<right && nums[right]>=base) right--;
        if(left<right){
            swap(nums[left],nums[right]);
        }
    }
    nums[begin]=nums[left];
    nums[left]=base;
    
    MySort(nums,begin,left-1);
    MySort(nums,left+1,end);
    
}
```

# 中序遍历

```c++
vector<int> inorder(TreeNode* root){
    stack<TreeNode*> st;
    vector<int> ans;
    while(root || !st.empty()){
        while(root){
            st.push(root);
            root=root->left;
        }
        TreeNode* temp=st.top();
        st.pop();
        ans.push_back(temp->val);
        root=temp->right;
    }
    return ans;
}
```

# 二分+并查集

n个人，差别值为能力值和性格值之差的和，差别值不超过L的两个人必然在一个组里，所有人至少能分成k个非空小组，规定的差别值上限是多少。

```c++

#include<vector>
#include<iostream>
#define ll long long
using namespace std;
int n, k;
vector<ll> a;
vector<ll> b;
ll g[501][501];
int father[501];
ll dis(int i, int j) { return abs(a[i] - a[j]) + abs(b[i] - b[j]); }
void init() {
	for (int i = 0; i <= n; i++) {
		father[i] = i;
	}
}
int find(int x) {
	if (x != father[x]) {
		father[x] = find(father[x]);
	}
	return father[x];
}
void merge(int x, int y) {
	int fx = find(x);
	int fy = find(y);
	if (fx != fy) {
		father[fx] = fy;
	}
}
bool check(ll x) {
	init();
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			if (g[i][j] <= x) {
				merge(i, j);
			}
		}
	}
	vector<bool> vis(n, false);
	for (int i = 0; i < n; i++) {
		vis[find(i)] = true;
	}
	int cur = 0;
	for (int i = 0; i < n; i++) {
		if (vis[i]) {
			cur++;
		}
	}

	return cur >= k;
}
int main() {
	cin >> n >> k;
	a.resize(n, 0);
	b.resize(n, 0);
	ll MIN = 1000000000;
	ll MAX = 0;
	for (int i = 0; i < n; i++) cin >> a[i];
	for (int i = 0; i < n; i++) cin >> b[i];
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			ll d = dis(i, j);
			g[i][j] = d;
			g[j][i] = d;
			MIN = min(MIN, d);
			MAX = max(MAX, d);
		}
	}
    // 差别值越大，分的小组越少
    // 差别值越小，分的小组越多
	ll l = MIN, r = MAX + 1;
	while (l < r) {
		int mid = (l + r) / 2;
		if (check(mid)) {
			l = mid + 1;
		}
		else {
			r = mid;
		}
	}
	cout << l - 1;
	return 0;
}
/*
3 2
1 9 3
2 7 8
*/
```





# 二进制倒置

```c++
#include <bits/stdc++.h>
using namespace std;

// string转化为vector<int>，倒序存储
vector<int> s2i(string& s) {
    vector<int> x;
    int idx = 0, n = s.size();
    for (; idx < n; ++idx) {
        if (s[idx] != '0') break;
    }
    if (idx == n) idx = n - 1;
    for (int i = n-1; i >= idx; --i) {
        x.push_back(s[i]-'0');
    }
    return x;
}

// a进制下x%b，x倒序存储
int mod(vector<int>& x, int a, int b) {
    int n = x.size(), q = 0;
    for (int i = n-1; i >= 0; --i) {
        q = (q * a + x[i]) % b;
    }
    return q;
}

// a进制下x/b，x倒序存储
void div(vector<int>& x, int a, int b) {
    int n = x.size(), q = 0;
    for (int i = n-1; i >= 0; --i) {
        x[i] += q * a;
        q = x[i] % b;
        x[i] /= b;
    }
    for (int i = n-1; i > 0; --i) {
        if (x[i]) break;
        x.pop_back();
    }
}

// a进制下s转化为b进制string
string convert(string s, int a, int b) {
    // 转换成大数在高位
    vector<int> x = s2i(s);
    int n = x.size();
    vector<int> y;
    while (n > 0) {
        // x是a进制数，用b求余
        y.push_back(mod(x, a, b));
        // x是a进制数，用b求商
        div(x, a, b);
        n = x.size();
        if (n == 1 && !x[0]) break;
    }
    int m = y.size();
    string res = "";
    for (int i = m-1; i >= 0; --i) {
        res += '0' + y[i];
    }
    return res; 
}

int main() {
    int T;
    cin >> T;
    string x;
    for (int t = 0; t < T; ++t) {
        cin >> x;
        string x2 = convert(x, 10, 2);
        reverse(x2.begin(), x2.end());
        string res = convert(x2, 2, 10);
        cout << "case #" << t << ":" << endl;
        cout << res << endl;
    }
    return 0;
}
```

