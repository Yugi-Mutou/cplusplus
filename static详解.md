# static详解

## static的种类

1. 静态全局变量：
   - 用于全局变量时，该变量具有内部链接属性，代表只能在当前源文件中可见，甚至用extern试图声明访问都不可以。
   - 在程序启动时被分配内存，直到程序结束时才被销毁
2. 静态局部变量:
   - 在函数内部声明的静态局部变量在函数的多次调用之间保持它们的值
   - 静态局部变量仅在第一次调用函数时初始化，并在程序的整个生命周期中保持它们的值。

3. 静态函数：
   - 用于函数声明时，该函数具有内部链接属性，只在当前源文件中可见，extern不可访问

4. 静态成员变量：

   - 在类中声明的静态成员变量与类的所有实例共享，而不是每一个实例都有自己的拷贝。

   - **静态成员变量需要在类的外部进行定义和初始化**

   - 与全局变量类似，在程序启动时被分配内存，直到程序结束时才被销毁

5. 静态成员函数：

   - 静态成员函数与类相关，而不是与类的实例相关，它可以在类没有创建任何实例的时候调用。

   - 静态成员函数只能访问类的静态成员变量，**因为它不能使用this指针**

编码的一些发现：

- **当你尝试获取成员函数的地址时，必须显式限定成员函数的名称。**
  - 在C++中，成员函数属于类或结构体的一部分，因此在获取成员函数的地址时，需要明确指定成员函数所属的类或结构体。这是因为不同的类可以有相同名称的成员函数，编译器需要明确知道你要获取哪个类的成员函数地址。
- 即使是在类里面，成员函数的调用也需要一个实例，不能直接用函数名来调用，但是静态成员函数可以直接用函数名来调用。



## static变量的内存分配

1. 静态全局变量：**在程序启动之前(main函数执行之前)就分配了空间并进行了初始化**。存储在程序的数据段
2. 静态局部变量：**在程序加载时分配空间，但是它们的初始化发生在第一次执行到定义语句时**。一旦初始化就在整个程序运行期间都保持分配状态(数据段)，程序停止才被释放
3. 静态类成员变量：**静态类成员变量在程序启动之前分配空间并进行初始化**。通常也存储在程序数据段中。静态类成员变量在类中声明，在类外定义，因为它与所有实例共享，而不是每个实例都有其拷贝。

程序数据段：**静态存储区**或**全局存储区**，程序启动时分配空间并初始化

## 静态存储区

静态存储区通常可以分为以下几个部分：

1. 数据段 (代码段)（Data Segment）：**用于存储已初始化的全局变量和静态局部变量**。在编译时，这些变量的初始值会被写入可执行文件的数据段中，程序运行时会将数据段的内容加载到静态存储区。
2. BSS段 (读写段)（Block Started by Symbol）：**用于存储未初始化的全局变量和静态局部变量**。BSS段在可执行文件中只保存变量的名称和大小，并在程序运行时分配内存并初始化为零值。
3. 常量区：用于存储常量数据

静态的都是编译器做得事情，编译器做得事情，就是放到静态存储区



## static变量(编译)

程序的加载过程可以简化为以下几个步骤：

1. 编译器在编译阶段为静态全局变量生成相应的符号表和初始化指令。
2. 链接器将编译后的目标文件连接成可执行文件。在这个过程中，静态全局变量被分配到程序的数据段（有时也叫静态存储区或全局存储区）。
3. **当程序被加载到内存时，操作系统为静态全局变量分配空间**，并**根据编译器生成的指令进行初始化**。
4. 在程序执行的过程中，静态全局变量会一直保持分配状态，直到程序终止



具体加载到内存的过程如下：

1. 装入（Loading）：操作系统根据可执行文件的文件格式和指令内容，将程序的代码段、数据段、堆区和栈区等部分加载到进程的虚拟地址空间中。
2. 重定位（Relocation）：如果可执行文件中存在与地址相关的引用，如绝对地址或相对地址，操作系统会对这些引用进行修正，以适应当前加载的内存地址。
3. 内存映射（Memory Mapping）：操作系统将加载的程序映射到物理内存中的适当位置，以便进程能够访问和执行其中的指令和数据。
4. 初始化和准备：一些初始化工作可能会在加载到内存后进行，例如静态变量的初始化、全局数据的设置等。此外，操作系统还会为进程分配栈空间、堆空间等。

一旦程序被加载到内存中，并且进程的初始化工作完成，操作系统会将控制权交给程序的入口点（如`main`函数），程序开始执行。





## 静态函数内部链接

在C++中，无论是普通函数还是静态函数，它们的函数定义都可以在一个或多个源文件中定义，但是它们的作用域和链接性是不同的。

**普通函数（非静态函数）**：

- 普通函数的作用域是全局的，它们可以被同一源文件中的其他函数直接调用，也可以被其他源文件中的函数调用。
- 普通函数具有外部链接（external linkage），**这意味着它们的定义被放置在生成的目标文件中的符号表中**，可以在链接阶段被其他源文件访问和调用。

**静态函数**：

- 静态函数的作用域是局部的，它们只能在定义它们的源文件中直接调用，不能被其他源文件访问。
- 静态函数具有内部链接（internal linkage），这意味着它们的定义被限制在单个编译单元（通常是一个源文件）中，**不会放置在生成的目标文件的符号表中**。因此，在其他源文件中无法通过函数名直接访问和调用静态函数。

无论是普通函数还是静态函数，它们的定义都被存储在源文件中。在编译时，每个源文件都会被独立编译成一个目标文件，然后在链接阶段将这些目标文件合并成最终的可执行文件。对于普通函数，它们的定义会被包含在生成的目标文件中的符号表中，以供其他源文件进行链接和调用。对于静态函数，它们的定义只在定义它们的源文件中可见，不会被放置在生成的目标文件的符号表中，因此无法在其他源文件中直接调用
