# 可虚不可虚

- 构造函数不可以是虚函数
  - 在每个构造函数中，会首先调用其直接基类的构造函数来初始化基类部分，然后再进行派生类自身的初始化。
  - 虚函数表由类的实例化对象的虚指针指向，需要用构造函数初始化，如果构造函数是虚函数，那么调用构造函数就需要去找虚指针，但此时虚指针还没有初始化呢。
  - 并且虚函数主要是实现多态，而构造函数是提供初始化对象生命周期只运行一次，不是动态行为
  - 构造函数根据对象类型自己主动调用的，不能通过引用或指针调用，所以实现了虚函数也没意义。

- 析构函数可以且常常是虚函数
  - 虚指针已经初始化了，完全可以把析构函数放在虚函数表里面来调用
  - c++类有继承时，析构函数必须为虚函数，基类的析构一定加virtual
  - 析构函数不是虚函数的话，直接按指针类型调用该类型的析构函数代码，因为指针类型是基类，所以直接调用基类析构函数代码。

- 模版函数不可以是虚函数
  - 虚表在各个同类对象间共享，实际上存在全局区。
  - 虚表是在编译阶段建立的，因此虚表的大小是确定的。成员函数模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定，因为模版虚函数个数不确定
  
- 内联函数与虚函数
  - 内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
  
  - 但是inline这个东西很软，你不管是能不能都可以加，反正如果不能内联编译器会给它优化掉。
  

