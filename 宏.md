# 宏

## UE中的宏MACROS

在Unreal Engine 4的蓝图系统中，宏（Macros） 是一种用于封装和重用逻辑片段的方法。宏允许您将一组蓝图节点组合成一个自定义节点，进而简化和整理蓝图逻辑。宏不仅可以提高蓝图的可读性，还可以在多个地方重用相同的逻辑，从而提高开发效率。

- 宏的特点和用途如下：
  - 封装逻辑：宏使您可以将一组相关的蓝图节点组合成一个单一的自定义节点，使蓝图看起来更简洁，更容易理解。
  - 重用代码：宏可以在同一个蓝图或不同的蓝图中多次使用，这有助于减少重复的逻辑代码。只需创建一次宏，然后在需要的地方调用它。
  - 多个输出引脚：与函数不同，宏可以具有多个输出引脚，这意味着您可以根据不同的条件输出多个结果。这在某些情况下可以替代多个分支节点，使蓝图更加整洁。
  - 编译时展开：宏在编译时展开，这意味着它们的逻辑会直接插入到调用它们的地方。这与函数不同，函数在运行时调用。由于宏在编译时展开，它们通常具有更高的性能

要创建一个宏，需要在蓝图编辑器中切换到Macro面板。在这里，您可以添加输入和输出引脚，然后在工作区中添加和连接蓝图节点以实现宏的逻辑。创建宏后，您可以在Event Graph、Function Graph或其他Macro Graph中调用它，就像使用任何其他蓝图节点一样。

总之，宏是一种在Unreal Engine 4的蓝图系统中封装和重用逻辑片段的方法。它们可以简化蓝图、提高代码的可读性和可维护性，并在许多情况下提高性能。





## C++中的宏

在C++中，**宏（Macro）**是一种预处理指令，它允许您在编译时用一段代码替换另一段代码。宏在C++中主要通过预处理器（Preprocessor）进行处理。预处理器是在编译器处理源代码之前运行的一个独立程序，用于文本替换、条件编译、文件包含等操作。

- C++宏的主要用途如下：

  - 文本替换：宏可以用来在编译时将一段文本替换为另一段文本。这对于定义常量、简化代码或实现特定的优化非常有用。

  - 条件编译：使用宏，您可以在编译时根据特定条件选择性地包含或排除代码。这在为不同平台或配置编译代码时非常有用。

  - 代码生成：宏还可以用于生成代码，例如创建多个类似的函数或类。这可以帮助减少重复代码和提高代码可维护性。

C++中的宏主要通过#define预处理指令定义。例如：

```c++
#define PI 3.14159
```


这个宏定义了一个名为PI的常量，它的值为3.14159。在编译时，预处理器会将所有出现PI的地方替换为3.14159。

宏还可以带有参数，例如：

```c++
#define MIN(a, b) ((a) < (b) ? (a) : (b))
```


这个宏定义了一个名为MIN的宏，它接受两个参数a和b，并返回它们之间的较小值。在编译时，预处理器将所有使用MIN的地方替换为相应的代码，例如MIN(3, 4)将被替换为((3) < (4) ? (3) : (4))。

虽然宏在某些情况下很有用，但它们也有一些潜在的缺点，如代码可读性降低、调试困难和潜在的错误。因此，在许多情况下，使用内联函数、常量表达式和模板可能是更好的选择。然而，在某些特定场景中，宏仍然具有其优势和用途。



## 宏与常量表达式比较

和常量表达式都可以在C++中用于定义常量或常量表达式，但它们在语法、类型安全和编译时处理上有一些不同之处。下面将通过举例来说明宏和常量表达式的区别：

```c++
# 宏（Macro）:
#define PI 3.14159
# 常量表达式（constexpr）:
constexpr double PI = 3.14159;
```

在这个例子中，我们使用宏和常量表达式分别定义了一个名为PI的常量。

区别:

1. 类型安全：宏没有类型信息，而常量表达式是类型安全的。在上面的例子中，PI宏可以被用于任何需要浮点数的地方，而编译器不会检查类型。另一方面，PI常量表达式是double类型，编译器会检查类型匹配。这有助于避免潜在的类型错误。

2. 作用域：宏没有作用域概念，它们在整个源文件中都是可见的，除非使用#undef取消定义。常量表达式遵循C++的作用域规则，这使得代码更易于维护和理解。

3. 计算方式：宏在预处理时进行文本替换，没有进行任何计算。在编译时，宏替换后的代码才会进行计算。常量表达式在编译时计算，因此在代码中使用常量表达式可以确保计算结果是在编译时得到的。

4. 调试：由于宏是在预处理阶段进行文本替换的，因此在调试时可能会更加困难。常量表达式更容易调试，因为它们在编译时计算并遵循C++的类型和作用域规则。

在许多情况下，使用常量表达式是比使用宏更好的选择，因为它们是类型安全的，遵循作用域规则，并且更容易调试。然而，在某些特定场景中，宏仍然具有其优势和用途。

## 预处理与编译

在编译时进行计算意味着在编译阶段，即生成目标代码之前，就已经对表达式进行了计算，并得到了结果。

以constexpr为例，它表示一个在编译时求值的常量表达式：

```c++
constexpr int square(int x) {
    return x * x;
}
constexpr int result = square(4); // 在编译时计算结果为 16
```

在上面的例子中，square函数用constexpr修饰，表示它是一个编译时函数。然后我们使用square(4)计算一个**constexpr int**类型的变量result。

编译器会在编译阶段计算square(4)的结果，并将result的值设为16。因此，在生成目标代码时，result已经被其结果16所替代。

这与使用宏进行计算有所不同，因为宏在预处理阶段进行文本替换，而不是在编译阶段计算。在预处理阶段，宏仅仅是将源代码中的宏替换为相应的代码或值。在编译阶段，替换后的代码才会进行计算。

例如：

```c++
#define SQUARE(x) ((x) * (x))
#define ST(A) ((A)*(A));
int a = 3;
int temp = SQUARE(a++); // 结果是 9
int result=ST(a); //结果不是预期的16，而是25

constexpr int square(int x) {
    return x * x;
}
int a = 3;
int temp = square(a++); 
int result=ST(a); //结果是预期的16
```


SQUARE(a++)宏会在预处理阶段被替换为((a++) * (a++))，导致a被递增两次，从而产生副作用。如果使用constexpr函数，就不会出现这个问题。



## 使用宏的好处

使用宏的好处如下：

1. 简化代码：宏可以用来定义一些常量、函数、条件编译等，可以使代码更加简洁明了，易于维护和理解。
2. 提高代码的可读性：宏可以用来定义一些易于理解的符号，例如宏定义可以用于定义常量、枚举值、函数名、变量名、数据类型等等，这些符号可以使代码更加易于理解和维护。
3. 提高代码的可移植性：宏可以用于定义与平台无关的代码，例如可以使用宏定义来表示不同平台的常量、函数、数据类型等，这样可以使代码更加具有可移植性，可以在不同的平台上运行。
4. 提高代码的重用性：宏可以用于定义一些通用的代码，例如可以使用宏定义来表示一些常用的算法、数据结构、函数等，这样可以使代码更加具有重用性，可以在不同的程序中多次使用。
5. 提高编译效率：宏可以用于避免重复编译，例如可以使用宏定义来避免重复包含头文件，这样可以减少编译时间，提高编译效率。







# const和constexpr

在C++中，`const`和`constexpr`是两个关键字，用于指定常量。

1. `const`关键字用于**声明一个常量**，表示该值在程序执行期间是不可修改的。它可以用于变量、函数参数和函数返回值。`const`修饰的变量在编译时期确定其值，并且在运行时不可修改。

   ```c++
   const int x = 5;
   ```

2. `constexpr`关键字用于**声明一个常量表达式**，表示**在编译时期就可以计算出结果的表达式**。它可以用于变量、函数和**类的成员函数**。`constexpr`修饰的变量或函数在编译时期就被计算出结果，并且可以用于编译时期的常量表达式。

   ```c++
   constexpr int y = 10;
   constexpr int z = x + y;
   
   class MyClass {
   public:
       constexpr int multiply(int a, int b) const {
           return a * b;
       }
   };
   
   int main() {
       constexpr MyClass obj;
       constexpr int result = obj.multiply(5, 10); // 在编译时期计算结果
   
       std::cout << "Result: " << result << std::endl;
   
       return 0;
   }
   ```

区别如下：

1. 编译时期计算：`const`修饰的变量在运行时期确定其值，而`constexpr`修饰的变量在编译时期就被计算出结果。
2. 表达式要求：`const`可以用于任何常量的定义，包括运行时期才能计算的表达式。`constexpr`要求表达式在编译时期就可以计算出结果。
3. 使用场景：`const`适用于在运行时期确定常量值的情况，而`constexpr`适用于在编译时期就可以确定常量值的情况。
4. 常量表达式不一定是常量，上的result被声明为`constexpr`，这意味着编译器在编译时期就可以确定它的值。因此，可以将`result`用于编译时期的常量表达式，例如作为数组大小、模板参数等，但是result本身并不是一个运行时期的常量。