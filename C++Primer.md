# C++Primer

## 小知识

### 迭代器和指针

1. 迭代器
   1. 迭代器不是指针，是类模板。重载了指针的一些操作符，本质是封装了原生指针，相当于一种智能指针。
   2. 迭代器返回的是对象的引用，而不是对象的值。
   3. 能一次访问容器中的各个元素，通过迭代器，容器和算法可以结合起来，对算法给与不同的迭代器，就可以对不同容器进行相同的操作
   4. 迭代器使用后就释放了，不能再继续使用
2. 指针
   1. 指针能指向函数，迭代器不行
   2. 指针只能指向某些特定容器。

### 类的存储(400)

类本身是没有存储空间的，只是说明里面有什么元素创建的时候要分配多少空间，在new的时候给其分配空间，放在堆中（动态内存）

### 参数列表后的const（232）

因为this的目的总是指向“自己”这个对象，所以默认情况下this是指向类类型的非常量版本的**常量指针**

参数列表后的const表示this是一个指向常量的常量指针，如果函数体内不会改变this所指对象，就把this设置成指向常量的指针，这样有助于提高函数的灵活性。即可以在一个常量对象上调用成员函数。

表示该函数不会修改**对象**的状态，因此在函数内部，通过this访问**对象**的成员变量时，不能修改这些成员变量的值，因为不能修改**对象**



### 智能指针(400)

定义在memory头文件中

shared_ptr允许多个指针指向指向同一个对象

unique_ptr则“独占”所指的对象

weak_ptr指向shared_ptr所管理的对象

最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。

**智能指针不支持指针算术运算**，但是可以用智能指针的get函数得到一个内置指针。

shared_ptr接受指针参数的构造函数是explicit的，因此必须使用直接初始化，而不能用赋值进行隐式转换的初始化(412)





### cbegin()和cend()

```
const_iterator cbegin() const noexcept;
```

和begin,end差不多，只是具有了底层const的属性，不能用于修改元素，本身的类型是const_iterator()。

类似于指向常量的迭代器，可以被递增或者递减，只是返回的迭代器不能用于修改元素而已。



### strlen与sizeof的区别

strlen(char*)

函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个’\0’，如果你只定义没有给它赋初值，这个结果是不定的，它会从数组首地址一直找下去，直到遇到’\0’停止。

sizeof()

sizeof()返回的是变量声明后所占的内存数，不是实际长度，此外sizeof不是函数，仅仅是一个操作符，strlen是函数。

- sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以'\0'结尾的

- 数组做sizeof的参数不退化，传递给strlen就退化为指针了

- 大部分编译程序在编译的时候就把sizeof计算过了，strlen的结果要在运行的时候才能计算出来，计算的是字符串的长度，而不是类型占内存的大小

  - ```c++
    char str[20]="0123456789";
    int a=strlen(str); //a=10
    int a=sizeof(str); //a=20
    ```



### new,delete和allocator类（427）

new将**内存分配**和**对象构造**组合在了一起

delete将**对象析构**和**内存释放**组合在了一起

allocator，它分配的内存是原始的、未构造的

### static详解

#### static的种类

1. 静态全局变量：
   - 用于全局变量时，该变量具有内部链接属性，代表只能在当前源文件中可见，甚至用extern试图声明访问都不可以。
2. 静态函数：
   - 

类的静态成员是属于类的成员，而不是属于类的任何一个对象的成员。

静态数据成员：与任何对象都不相关，而是与类本身相关联。被所有对象共享，在内存中只有一份拷贝。可以在类内部声明，在类外部定义和初始化。

类的静态成员变量的存储位置和生命周期与全局变量类似，它们在程序启动时被分配内存，直到程序结束时才被销毁。

静态函数成员：静态函数成员与类的任何对象都不相关，而与类本身相关。可以直接通过类名调用，无需通过类的对象来调用。静态函数成员不能访问类的非静态成员，也**不能使用this指针**。

### auto和decltype的区别

`auto` 和 `decltype` 都是 C++11 中引入的新特性，它们的主要作用都是为了简化代码，提高编码效率。它们之间的主要区别如下：

1. 变量类型的推导方式不同

`auto` 的类型推导是通过变量初始化表达式来进行的，编译器会根据变量初始化表达式的类型来推导变量的类型。例如：

```c++
auto i = 10; // 推导 i 的类型为 int
auto d = 3.14; // 推导 d 的类型为 double
```

`decltype` 的类型推导是通过表达式来进行的，编译器会根据表达式的类型来推导变量的类型。例如：

```c++
int i = 10;
decltype(i) j = i; // 推导 j 的类型为 int
```

1. 对于函数类型推导的支持不同

`auto` 支持推导函数的返回值类型，但是不支持推导函数类型本身。例如：

```c++
auto func() -> int { return 0; } // 推导函数返回值类型为 int
auto func2 = func; // 错误，无法推导函数类型本身
```

`decltype` 支持推导函数类型本身和返回值类型，例如：

```c++
decltype(func) func3; // 推导 func3 的类型为 int()，即函数类型
decltype(func()) i; // 推导 i 的类型为 int，即函数 func 的返回值类型
```

1. 表达式的求值方式不同

在使用 `auto` 进行类型推导时，编译器会根据变量初始化表达式的类型来推导变量类型，而不会对表达式进行求值。例如：

```c++
int i = 10;
auto j = i / 0; // 不会报错，j 的类型被推导为 int
```

在使用 `decltype` 进行类型推导时，编译器会对表达式进行求值，从而推导出表达式的类型。例如：

```c++
int i = 10;
decltype(i / 0) j; // 编译错误，i / 0 表达式会导致除以 0 的运行时错误
```

因此，使用 `decltype` 进行类型推导时需要特别注意表达式的求值方式。



### 拷贝构造、析构函数(440)

#### 拷贝构造函数

拷贝构造函数的第一个参数**必须是一个引用类型**，并且这个参数通常是一个const的引用

拷贝构造函数通常会被隐式的使用，所以不应该是explicit

如果没有定义拷贝构造函数，编译器会合成一个拷贝构造函数

```c++
#include<string>
using std::string;
class HasPtr
{
public:
	HasPtr(const string& s = string()) :ps(new string(s)), i(0) {  }
	HasPtr(const HasPtr& hp) :ps(new string(*hp.ps)), i(hp.i) {}
	HasPtr& operator=(const HasPtr& rhs_hp) {
		if (this != &rhs_hp) {
			string* temp = new string(*rhs_hp.ps);
			delete ps;
			// ps=temp;
			// i=rhs_hp.i;
			this->ps = temp;
			this->i = rhs_hp.i;
		}
		return *this;
	}
	~HasPtr() {
		// 手动释放内置指针类型所指的空间
		delete ps;
	}
private:
	string* ps;
	int i;
};
```

#### 析构函数

**析构函数不接受参数，因此也不能被重载**

先执行析构函数体，之后成员被销毁

析构函数体本身并不直接销毁成员，成员是在析构函数体执行之后隐含的析构阶段中被销毁的。

在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

**引用和指针**离开作用域时，析构函数不会执行



### 拷贝并交换技术(459)

这个技术的优点是简单易懂不容易出错，但是效率可能有点低。

因为拷贝赋值运算符只需要将右侧对象的拷贝给当前对象就行了。

但是拷贝并交换技术还要先通过拷贝构造函数创建出一个临时时的对象，可能开销会很大。

在某些场景下有更好的替代方法，比如，对非指针类型的类数据成员，逐个赋值；对指针类型的类数据成员，使用智能指针或引用计数的方法来减少内存分配和释放的开销。



### 左值引用和右值引用

左值引用：

指一个对象的别名，可以被取地址操作符&所取得其地址。左值引用只能绑定到左值**（具有内存地址的对象）**，例如变量、对象成员、数组元素。

右值引用：

指一个对象的临时对象（右值）的别名，可以被std::move所取得其地址。右值引用只能绑定到右值**(没有内存地址的临时对象)**，例如函数返回值、**字面常量（在编译时计算出来，而不需要再程序执行期间分配内存空间）**。

**左值还是右值关键看有没有内存地址**

**P473页**：

通常要先destroy销毁对象之后，再使用deallocate释放为对象分配的内存空间。

但是因为使用了右值引用，让一个新的对象接管了原来的对象，所以不能destroy销毁原对象内存，而是直接使用deallocate，让右值引用放弃掉原来的资源，给新创建的对象。

**P480页**

std::move将其参数转换为右值引用类型，并返回该右值引用

右值引用表示可被移动的对象或临时对象。右值引用允许我们对一个对象进行移动操作，而不是传统的复制操作，提高了程序的性能

std::move函数的作用是讲一个左值对象转换为右值引用，从而允许我们对其进行移动操作而不是复制操作。

std::move并不会真正的将对象移动，它只是将对象的类型转换为右值引用类型，从而告诉编译器可以使用移动操作。实际的移动操作是由移动构造函数或者移动赋值运算符来完成的。





### 静态类型和动态类型（P536）

在 C++ 中，每个对象都有一个静态类型和一个动态类型。

静态类型是在编译时就已经确定的，它指的是对象在声明时所使用的类型。例如：

```c++
int x = 10;  // x 的静态类型是 int
```

在上面的代码中，变量 x 的静态类型和动态类型都是 int，因为它在声明时使用了 int 类型，同时由于x的值也是一个int，所以动态类型也是int。

动态类型是在运行时确定的，它指的是对象当前所指的类型。例如：

```c++
int* p = new int;
*p = 10;
```

在上面的代码中，我们创建了一个 int 类型的动态对象，并将指针 p 指向它。此时，指针 p 的静态类型是 int*，动态类型也是 int*，因为它指向的是一个 int 类型的对象。

下面是另一个例子：

```c++
class A {
public:
    virtual void foo() {
        cout << "A::foo()" << endl;
    }
};

class B : public A {
public:
    void foo() {
        cout << "B::foo()" << endl;
    }
};

int main() {
    A* p = new B;
    p->foo();  // 输出 B::foo()
    return 0;
}
```

在上面的代码中，我们定义了两个类 A 和 B，其中 B 继承自 A，并重写了 A 中的虚函数 foo()。在 main 函数中，我们创建了一个指向 B 对象的指针 p，然后调用它的 foo() 函数。此时，指针 p 的静态类型是 A*，动态类型是 B*，因为它指向的是一个 B 类型的对象。

总之，静态类型是在编译时就已经确定的，而动态类型是在运行时才能确定的。**动态类型的确定是由指针所指向的对象类型决定的，而静态类型则是由变量的声明类型决定的。在 C++ 的多态机制中，动态类型的概念非常重要，它决定了虚函数的实际调用。**



### 全局变量和静态变量

全局变量：

1. 存储在全局数据区或数据段
2. 程序的一部分，**启动时就被分配**，程序结束被释放，存储方式是静态的
3. 其值可以被任何函数访问和修改

静态变量:

1. 存储在全局数据区或数据段
2. 只被初始化一次，**只有在用到的时候才会被分配存储空间**，存储方式是动态的
3. 变量作用域限制在当前文件中，其他文件无法访问这个变量



### dynamic_cast举例说明

`dynamic_cast` 是 C++ 中一种类型转换运算符，用于在运行时进行类型安全的向下转型。它可以将指向基类的指针或引用转换为指向派生类的指针或引用。

`dynamic_cast` 的使用方法如下：

```c++
cppCopy codeclass Base {
public:
    virtual void foo() {}
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void bar() {}
};

int main() {
    Base* b = new Derived;
    Derived* d = dynamic_cast<Derived*>(b);
    if (d) {
        // b 指向的对象是 Derived 类型
        d->bar();
    } else {
        // b 指向的对象不是 Derived 类型
    }
    delete b;
    return 0;
}
```

在上面的代码中，我们定义了一个基类 `Base` 和一个派生类 `Derived`，并在 `main` 函数中创建了一个指向 `Derived` 类型的对象 `b`，并通过 `dynamic_cast` 将它转换为指向 `Derived` 类型的指针 `d`。如果转换成功，则可以使用 `d` 来访问 `Derived` 类型的成员函数 `bar()`；如果转换失败，则 `d` 将为 `nullptr`。

需要注意的是，`dynamic_cast` 只能用于指针或引用类型的转换，不能用于转换基本类型。此外，它只能将指向多态类的基类指针或引用转换为指向派生类的指针或引用，而不能将指向非多态类的指针或引用进行转换。



### 箭头运算符

编译器在遇到箭头运算符（`->`）时会自动解引用指针并访问成员，因为这是箭头运算符在 C++ 语言中的设计和预期行为。箭头运算符是 C++ 语法的一部分，它的目的是简化指针类型的对象成员访问。

当你使用箭头运算符（`->`）时，它的行为如下：

1. 对于指针类型的对象，箭头运算符会自动解引用指针，并访问指向的对象的成员。
2. 对于非指针类型的对象，如果箭头运算符被重载，编译器会调用重载的箭头运算符。重载的箭头运算符通常返回一个指针，然后编译器会根据步骤1中的规则解引用指针并访问成员。





### lambda表达式本质上是一个匿名函数对象

在 C++ 中，lambda 表达式本质上是一个匿名函数对象。编译器会为每个 lambda 表达式生成一个唯一的未命名类。这个类会重载 `operator()`，以便能够像函数一样调用。

对于 lambda 表达式生成的类，编译器可能会根据捕获的数据成员类型生成默认的拷贝构造函数、移动构造函数或者它们的组合。这里是几个例子：

1. 如果 lambda 没有捕获任何变量，那么它会生成默认的拷贝构造函数和移动构造函数：

```c++
auto lambda1 = []() { return 42; };
```

1. 如果 lambda 捕获了具有默认拷贝构造函数和移动构造函数的变量，那么它也会生成默认的拷贝构造函数和移动构造函数：

```c++
int x = 42;
auto lambda2 = [x]() { return x; };
```

1. 如果 lambda 捕获了只有默认拷贝构造函数的变量（例如，一个拷贝构造函数被删除的类实例），那么它会生成默认的拷贝构造函数，但不会生成移动构造函数：

```c++
class NoMove {
public:
    NoMove() = default;
    NoMove(const NoMove&) = default;
    NoMove(NoMove&&) = delete;
};

NoMove no_move_instance;
auto lambda3 = [no_move_instance]() { /*...*/ };
```

1. 如果 lambda 捕获了只有默认移动构造函数的变量（例如，一个拷贝构造函数被删除的类实例），那么它会生成默认的移动构造函数，但不会生成拷贝构造函数：

```c++
class NoCopy {
public:
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy(NoCopy&&) = default;
};

NoCopy no_copy_instance;
auto lambda4 = [no_copy_instance = std::move(no_copy_instance)]() { /*...*/ };
```

所以，lambda 表达式产生的类的拷贝构造函数和移动构造函数的生成取决于捕获的数据成员类型。如果捕获的类型允许拷贝和/或移动构造，那么 lambda 类也会生成相应的构造函数。





### 为什么要尽量在.cpp文件中使用include

在C++项目中，头文件（.h文件）通常包含类、结构体和函数的声明，而源文件（.cpp文件）包含这些声明的实现。当一个文件包含另一个文件时，编译器会将被包含文件的内容复制到包含它的文件中。头文件包含会导致编译器需要处理更多的代码，从而增加编译时间。此外，头文件包含还可能导致循环依赖和重复编译，进一步增加编译时间。

将头文件包含限制在源文件（.cpp）中有以下好处：

1. **减少编译依赖**：在.cpp文件中包含头文件，可以让这个头文件仅对这个.cpp文件产生依赖，而不会影响其他文件。这样，当头文件发生变化时，只需要重新编译直接依赖该头文件的源文件，而不是所有包含该头文件的文件。
2. **减少编译时间**：将头文件包含在源文件中，可以减少编译器需要处理的代码量。当头文件只包含必要的声明，而实现放在源文件中时，编译器需要处理的代码会更少。这样，即使在项目中有许多文件时，编译时间也能得到有效控制。
3. **避免循环依赖**：头文件包含很容易导致循环依赖问题，这是因为头文件A可能包含头文件B，而头文件B又包含头文件A。通过将包含限制在源文件中，并使用前向声明来引用类或结构体，可以避免循环依赖问题。
4. **提高代码可读性和可维护性**：将头文件包含限制在源文件中，有助于使头文件保持简洁，只包含必要的声明。这样，其他开发人员更容易理解代码结构和功能。此外，减少头文件包含还有助于降低代码重构的复杂性。

通过将头文件包含限制在源文件中，你可以减少不必要的编译依赖，缩短编译时间，避免循环依赖问题，并提高代码的可读性和可维护性。这是一种在C++和Unreal Engine项目中广泛采用的最佳实践。



### c++编译流程

C++ 编译流程通常分为四个主要阶段：

1. 预处理（Preprocessing）：在这个阶段，预处理器会处理源代码中的预处理指令，例如 `#include`、`#define` 和 `#ifdef` 等。这些指令通常用于引入头文件、定义宏或条件编译。预处理器将处理这些指令，替换源代码中的宏，并将头文件的内容插入源代码中，生成预处理后的源代码。
2. 编译（Compilation）：在这个阶段，编译器将预处理后的源代码转换为目标代码（通常是汇编语言或机器代码）。编译器还会对代码进行优化以提高运行时性能。此阶段的输出称为目标文件（Object File），通常扩展名为 `.o`（Linux 或 macOS）或 `.obj`（Windows）。
3. 链接（Linking）：在这个阶段，链接器将各个目标文件与库文件（如标准库或第三方库）连接在一起，生成可执行文件或库文件。链接器会解决目标文件之间的相互依赖关系，处理符号引用，合并代码段和数据段等。最终生成的可执行文件通常扩展名为 `.out` 或无扩展名（Linux 或 macOS）或 `.exe`（Windows）。
4. 运行时加载（Runtime Loading）：当你运行可执行文件时，操作系统会将其加载到内存中，并解析动态链接库（例如共享库或 DLL 文件）。操作系统将这些库文件加载到内存，并将它们与可执行文件进行链接。一旦所有依赖关系都解析完毕，程序将开始执行。
