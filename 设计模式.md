# 设计模式

当涉及到设计模式的代码示例时，单例模式和工厂模式是两个常用的设计模式。

1. 单例模式（Singleton Pattern）的C++代码示例：

```c++
class Singleton {
private:
    static Singleton* instance;
    
    // 私有构造函数，防止外部实例化
    Singleton() {}
    
public:
    // 获取单例实例的静态方法
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // 其他成员函数
    void someFunction() {
        // 实现代码
    }
};

Singleton* Singleton::instance = nullptr;

// 使用单例
Singleton* singletonInstance = Singleton::getInstance();
singletonInstance->someFunction();
```

在上述代码中，`Singleton` 类通过一个私有的静态指针变量 `instance` 来存储唯一的实例。通过静态的 `getInstance()` 方法，我们可以获取该实例。如果实例尚未创建，`getInstance()` 方法会实例化一个新的对象并将其赋值给 `instance` 变量，然后返回该实例。这确保了在整个应用程序中只有一个 `Singleton` 实例存在。

1. 工厂模式（Factory Pattern）的C++代码示例：

```c++
// 基类
class Product {
public:
    virtual void use() = 0;
};

// 具体产品类 A
class ConcreteProductA : public Product {
public:
    void use() override {
        // 实现代码
    }
};

// 具体产品类 B
class ConcreteProductB : public Product {
public:
    void use() override {
        // 实现代码
    }
};

// 工厂类
class Factory {
public:
    Product* createProduct(int type) {
        switch (type) {
            case 1:
                return new ConcreteProductA();
            case 2:
                return new ConcreteProductB();
            default:
                return nullptr;
        }
    }
};

// 使用工厂创建产品
Factory factory;
Product* productA = factory.createProduct(1);
productA->use();
```

在上述代码中，我们定义了一个基类 `Product`，并派生了两个具体产品类 `ConcreteProductA` 和 `ConcreteProductB`。工厂类 `Factory` 中的 `createProduct()` 方法根据传入的参数类型来实例化具体的产品对象并返回。通过调用工厂类的 `createProduct()` 方法，我们可以创建具体的产品实例并使用它们。

需要注意的是，工厂模式通过封装了具体对象的创建过程，使得客户端代码与具体产品类解耦，只需要与工厂类进行交互。这样可以实现更好的灵活性和可扩展性，当需要添加新的产品时，只需修改工厂类而无需修改客户端代码。





## UE中的单例设计模式

在UE4中，有一些重要的类或功能使用了单例设计模式来确保全局唯一的访问点和共享资源。以下是一些在UE4中使用单例设计模式的常见类或功能：

1. `GEngine`：`GEngine` 是一个全局的引擎对象，用于管理游戏引擎的核心功能，例如渲染、输入、声音等。它使用单例设计模式来提供全局访问点，以便在代码的任何地方使用引擎功能。
2. `GWorld`：`GWorld` 是一个全局的世界对象，代表当前正在运行的游戏世界。它使用单例设计模式，使得开发者可以方便地在任何地方访问和操作世界的对象、角色、事件等。
3. `UGameInstance`：`UGameInstance` 是游戏实例的抽象类，用于管理游戏实例级别的数据和逻辑。在一个游戏实例中只会存在一个 `UGameInstance` 对象，它使用单例设计模式来确保全局唯一的访问点。
4. `UWorld`：`UWorld` 是一个游戏世界的运行时实例，代表游戏中的一个独立运行环境。在一个游戏中可以存在多个 `UWorld`，但每个 `UWorld` 实例都使用了单例设计模式，以确保在代码的任何地方都可以方便地访问和操作当前的游戏世界。
5. `FCoreDelegates`：`FCoreDelegates` 是一组核心委托，用于处理引擎级别的事件和回调。它使用单例设计模式，提供了全局访问点，以便注册和触发各种引擎事件。

这些只是在UE4中使用单例设计模式的一些例子，还有其他类和功能也可能使用了单例模式，以确保全局唯一性和方便的访问。使用单例设计模式可以简化代码结构，提供全局共享资源的访问点，并确保对象的唯一性，从而提高开发效率和代码的可维护性。





## UE中的工厂设计模式

在UE4中，有一些类或功能使用了工厂设计模式来创建和管理对象的实例。以下是一些在UE4中使用工厂设计模式的常见类或功能：

1. `UObjectFactory`：`UObjectFactory` 是一个抽象基类，用于创建 `UObject`（包括蓝图、材质、纹理等）的实例。它定义了创建对象实例的接口和方法，派生类可以根据需要实现具体的对象创建逻辑。
2. `UActorFactory`：`UActorFactory` 是用于创建 `AActor`（即游戏中的角色、物体等）的工厂类。它提供了创建角色实例的方法，并可以根据需要自定义创建过程。
3. `UWidgetComponentFactory`：`UWidgetComponentFactory` 是用于创建 `UWidgetComponent`（用于在3D场景中呈现UI控件）的工厂类。它负责创建 `UWidgetComponent` 实例，并可以设置默认的 Widget 类型和属性。
4. `FActorSpawnParameters`：`FActorSpawnParameters` 是一个结构体，用于在运行时创建 `AActor` 的实例。它包含了创建角色所需的参数，例如位置、旋转、拥有者等。通过使用这个结构体，可以在运行时动态地创建角色实例。
5. `FObjectInitializer`：`FObjectInitializer` 是一个结构体，用于在编译时创建 `UObject` 的实例，并初始化其属性和成员变量。它在定义类的构造函数时使用，并通过提供默认值来初始化对象的属性。

这些只是在UE4中使用工厂设计模式的一些例子。工厂模式在UE4中广泛应用，用于创建和管理各种对象实例，提供了一种灵活和可扩展的方式来创建复杂的对象结构，并隔离了对象的创建逻辑和客户端代码，从而提高了代码的可维护性和可测试性。