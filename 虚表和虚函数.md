# 虚表

在C++中，虚函数表（通常被称为vtable）是一个编译器在编译时期为每个包含至少一个虚函数的类或者包含虚函数的类的子类创建的表。vtable是用于支持动态多态的重要机制，特别是在处理指向基类对象的指针或引用时调用适当的派生类函数。

虚函数表是一个在类中的隐藏成员，**每个类只有一个虚函数表**。它包含一个指向类中所有虚函数的指针数组，这些指针按照它们在类声明中出现的顺序排序。当类被实例化时，会创建一个指向相关虚函数表的指针，称为虚指针。虚指针是对象的一部分，它被存储在对象的内存中。

考虑以下类定义：

```c++
class Base {
public:
    virtual void func1() { }
    virtual void func2() { }
};

class Derived : public Base {
public:
    void func1() override { }
    void func2() override { }
};
```

对于这两个类，编译器将会创建两个虚函数表：

Base的vtable包含Base::func1和Base::func2的地址。

Derived的vtable包含Derived::func1和Derived::func2的地址。

当你创建一个Base或Derived的对象时，这个对象会包含一个指向相应类的vtable的指针。所以如果你有一个指向Base的指针，并且这个指针实际上指向一个Derived对象，当你通过这个指针调用一个虚函数时，它会查找Derived的vtable并调用适当的函数。这就是动态多态性的工作原理。

## 虚函数表何时创建

**虚函数表在编译期间就已经确定，并在运行时使用**，所以在某种意义上，虚函数表是在类的生命周期开始时就被创建的。

**虚表在各个同类对象间共享，实际上存在全局区（静态存储区）（只读数据段）**

![img](https://img-blog.csdnimg.cn/2020082616593663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pNVzE0MDc=,size_16,color_FFFFFF,t_70#pic_center)

需要注意的是，**虚函数表和虚指针的具体实现是依赖于编译器的**，所以上述描述是一个常见的实现方式，但并非所有编译器都必须完全遵守这种方式。

虚表，虚函数，虚指针

**虚指针 堆**

**虚表 只读数据段**

**虚函数 代码段**



# 可虚不可虚

- 构造函数不可以是虚函数
  - 在每个构造函数中，会首先调用其直接基类的构造函数来初始化基类部分，然后再进行派生类自身的初始化。
  - 虚函数表由类的实例化对象的虚指针指向，需要用构造函数初始化，如果构造函数是虚函数，那么调用构造函数就需要去找虚指针，但此时虚指针还没有初始化呢。
  - 并且虚函数主要是实现多态，而构造函数是提供初始化对象生命周期只运行一次，不是动态行为
  - 构造函数根据对象类型自己主动调用的，不能通过引用或指针调用，所以实现了虚函数也没意义。

- 析构函数可以且常常是虚函数
  - 虚指针已经初始化了，完全可以把析构函数放在虚函数表里面来调用
  - c++类有继承时，析构函数必须为虚函数，基类的析构一定加virtual
  - 析构函数不是虚函数的话，直接按指针类型调用该类型的析构函数代码，因为指针类型是基类，所以直接调用基类析构函数代码。

- 模版函数不可以是虚函数
  - 虚表在各个同类对象间共享，**存在只读数据段**。
  - 虚函数表是根据类的定义在编译阶段生成的，模板的实例化是根据模板参数在编译阶段生成的。虽然，在编译阶段，虚函数表和模板的实例化都已经完成，但是二者是不同的概念，换句话说，模板实例化放不到虚表里
  - 虚表是在编译阶段建立的，且虚表的大小是确定的。也就是说，一个类有很多个对象，他们的虚指针指向的是同一张虚表，但是这些个对象由于模板类型参数不同，他们的模板函数都是不一样的。不可能把这些个对象所实例化出的各个类型的模板函数都放到虚表里，那样虚表就太大了 。

- 内联函数与虚函数
  - 内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。

  - 但是inline这个东西很软，你不管是能不能都可以加，反正如果不能内联编译器会给它优化掉。







# 自我感想

这么看C++中多态的实现其实主要依赖于虚函数表，因为虚函数表在编译期间创建，并且虚指针是实例的一部分，并被存储在对象中，所以自然而然的，不管你类型是什么，最后调用哪个函数还是要看虚指针指向哪里。
